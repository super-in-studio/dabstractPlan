<p><strong>总的流程就是要 返回 ConfigurableApplicationContext</strong></p><p><br></p><p><br></p><ul><li><strong>构建 SpringApplication </strong></li></ul><ol><li>指定main函数所在的类</li><li>通过全限命名 确认是什么类型的应用，servlet 和SpringwebContext</li><li>设置初始化器 应用容器初始化器</li><li>初始化监听器 从META-INF/spring.factories 中获取权限命名 并设置进去 SpringApplications里面</li></ol><attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-df82c5dd-0e5a-4637-bea0-d14cf523884b"></attachment><p><em>以下 是 spring.factories</em></p><p><em>org.springframework.context.ApplicationListener=\</em></p><p><em>org.springframework.boot.ClearCachesApplicationListener,\  清理缓存</em></p><p><em>org.springframework.boot.builder.ParentContextCloserApplicationListener,\ 关闭上线文的</em></p><p><em>org.springframework.boot.context.FileEncodingApplicationListener,\ 检查编码的</em></p><p><em>org.springframework.boot.context.config.AnsiOutputApplicationListener,\ </em><span style="color: rgb(77, 77, 77);">如果你的终端支持ANSI，设置彩色输出会让日志更具可读性。</span></p><p><em>org.springframework.boot.context.config.ConfigFileApplicationListener,\ 待查看</em></p><p><em>org.springframework.boot.context.config.DelegatingApplicationListener,\待查看:</em><span style="color: rgb(77, 77, 77);">把Listener转发给配置的这些class处理，这样可以支持外围代码不去写spring.factories中的org.springframework.context.ApplicationListener相关配置，保持springboot原来代码的稳定</span></p><p><em>org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\ 日志处理:</em><span style="color: rgba(0, 0, 0, 0.75);">根据配置初始化日志系统log</span></p><p><em>org.springframework.boot.context.logging.LoggingApplicationListener,\日志处理 :</em><span style="color: rgba(0, 0, 0, 0.75);">程序启动时，讲classpath打印到debug日志，启动失败时classpath打印到info日志</span></p><p><em>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener \</em><span style="color: rgb(77, 77, 77);">则使用springboot相关的版本进行替代</span></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><ul><li><strong>开始run方法拉！</strong></li></ul><p>1.初始化应用运行监听器的初始化</p><p>2.解析启动参数,构建environment，选择profiles,</p><p>springApplicationCommandLineArgs</p><p>3. 发布运行事件 --&gt;将环境属性填充进去运行监听器,(异步填充)</p><p>发现:</p><p>1.早期的事件处理逻辑是以set形式存在于 Context 中</p><p>2.事件分发器中能配置多线程加快启动速度（1）</p><p><br></p>