<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-41415574-2fe1-4960-a42b-e09379798a8a"></attachment><p>&nbsp;Spring的单例对象的初始化主要分为三步：&nbsp;</p><p><br></p><p><br></p><p>&nbsp;&nbsp;①：createBeanInstance：实例化，其实也就是 调用对象的构造方法实例化对象</p><p><br></p><p>&nbsp;&nbsp;②：populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</p><p><br></p><p>&nbsp;&nbsp;③：initializeBean：调用spring xml中的init() 方法。</p><p><br></p><p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。</p><p><br></p><p>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><p>这三级缓存分别指：</p><p><br></p><p>&nbsp;singletonFactories ： 单例对象工厂的cache&nbsp;</p><p>&nbsp;earlySingletonObjects ：提前暴光的单例对象的Cache 。【用于检测循环引用，与singletonFactories互斥】</p><p>&nbsp;singletonObjects：单例对象的cache</p><p>我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就就是：</p><p><br></p><p>protected Object getSingleton(String beanName, boolean allowEarlyReference) {</p><p>&nbsp;&nbsp;Object singletonObject = this.singletonObjects.get(beanName);</p><p>&nbsp;&nbsp;if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;synchronized (this.singletonObjects) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singletonObject = this.earlySingletonObjects.get(beanName);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (singletonObject == null &amp;&amp; allowEarlyReference) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (singletonFactory != null) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singletonObject = singletonFactory.getObject();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.earlySingletonObjects.put(beanName, singletonObject);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.singletonFactories.remove(beanName);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;return (singletonObject != NULL_OBJECT ? singletonObject : null);</p><p>}</p><p>上面的代码需要解释两个参数：</p><p><br></p><p>isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)</p><p>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</p><p>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：</p><p><br></p><p>this.earlySingletonObjects.put(beanName, singletonObject);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.singletonFactories.remove(beanName);</p><p>1</p><p>2</p><p>从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p><p><br></p><p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p><p><br></p><p>public interface ObjectFactory&lt;T&gt; {</p><p>&nbsp;&nbsp;T getObject() throws BeansException;</p><p>}</p><p>1</p><p>2</p><p>3</p><p>这个接口在下面被引用</p><p><br></p><p>protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {</p><p>&nbsp;&nbsp;Assert.notNull(singletonFactory, "Singleton factory must not be null");</p><p>&nbsp;&nbsp;synchronized (this.singletonObjects) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (!this.singletonObjects.containsKey(beanName)) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.singletonFactories.put(beanName, singletonFactory);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.earlySingletonObjects.remove(beanName);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.registeredSingletons.add(beanName);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p>}</p><p><br></p><p>这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p><br></p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p><p><br></p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</p><p><br></p><p><br></p><p><br></p>