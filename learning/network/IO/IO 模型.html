<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-3e89c49a-a9a8-4f07-953e-2373cdddbd02"></attachment><p><strong>BIO模型</strong></p><p><br></p><p>实现过程：</p><p>java.main() -&gt; socket , bind , listen -&gt; while(){ accept()} 阻塞，等待资源。</p><p><br></p><p>好处：一个service 可以接收N个Client , 每个连接对应一个线程</p><p>弊端：阻塞消耗资源，所以kernel引出非阻塞。</p><p><br></p><p><br></p><p><br></p><p><strong>NIO 模型</strong></p><p><br></p><p>实现过程：</p><p>java.main()-&gt;socket,bing,listen -&gt;accept 非阻塞 -&gt;  循环列表查看 是否有结果</p><p><br></p><p>好处：自己控制线程数量</p><p>弊端：加如有1万个连接，只有一个连接有消息，都要循环1万次。</p><p><br></p><p><br></p><p><strong>NIO 多路复用器 select, poll</strong></p><p>会主动通知列表中哪个元素有消息</p><p>好处：能主动通知，无需循环查询是否有消息</p><p>弊端：每次要传一大批数据给内核，重复传数据,内核需要遍历数据。</p><p><br></p><p><strong>NIO 多路复用器 epoll</strong></p><p>内核创建空间维护一个列表，记录监听的列表，</p><p><br></p><p>总结：</p><p>BIO,NIO,NIO多路复用器 都属于同步IO 模型，简单来说就是需要程序主动去获取消息。只是分为阻塞和非阻塞</p><p><br></p>