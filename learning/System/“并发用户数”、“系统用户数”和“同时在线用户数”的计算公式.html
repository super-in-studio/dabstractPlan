<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-7c0a6252-35d5-4cbe-9d4b-cd88153f74cd"></attachment><p>&nbsp;与并发用户数相关的概念还包括“并发用户数”、“系统用户数”和“同时在线用户数”，下面用一个实际的例子来说明它们之间的差别。</p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;假设有一个OA系统，该系统有2000个使用用户——这就是说，可能使用该OA系统的用户总数是2000名，这个概念就是“系统用户数”，该系统有一个“在线统计”功能（系统用一个全局变量记数所有已登录的用户），从在线统计功能中可以得到，最高峰时有500人在线（这个500就是一般所说的“同时在线人数”），那么，系统的并发用户数是多少呢？&nbsp;</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;根据我们对业务并发用户数的定义，这500就是整个系统使用时最大的业务并发用户数。当然，500这个数值只是表明在最高峰时刻有500个用户登录了系统，并不表示实际服务器承受的压力。因为服务器承受的压力还与具体的用户访问模式相关。例如，在这500个“同时使用系统”的用户中，考察某一个时间点，在这个时间上，假设其中40%的用户在较有兴致地看系统公告（注意：“看”这个动作是不会对服务端产生任何负担的），20%的用户在填写复杂的表格（对用户填写的表格来说，只有在“提交”的时刻才会向服务端发送请求，填写过程是不对服务端构成压力的），20%部分用户在发呆（也就是什么也没有做），剩下的20%用户在不停地从一个页面跳转到另一个页面——在这种场景下，可以说，只有20%的用户真正对服务器构成了压力。因此，从上面的例子中可以看出，服务器实际承受的压力不只取决于业务并发用户数，还取决于用户的业务场景。</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;在实际的性能测试工作中，测试人员一般比较关心的是业务并发用户数，也就是从业务角度关注究竟应该设置多少个并发数比较合理，因此，在后面的讨论中，也是主要针对业务并发用户数进行讨论，而且，为了方便，直接将业务并发用户数称为并发用户数。&nbsp;</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;（1） 计算平均的并发用户数： C = nL/T&nbsp;</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;（2） 并发用户数峰值： C’ ≈ C+3根号C</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;公式（1）中，C是平均的并发用户数；n是login session的数量；L是login session的平均长度；T指考察的时间段长度。</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;公式（2）则给出了并发用户数峰值的计算方式中，其中，C’指并发用户数的峰值，C就是公式（1）中得到的平均的并发用户数。该公式的得出是假设用户的login session产生符合泊松分布而估算得到的。</span></p><p><span style="color: rgb(51, 51, 51);">实例：</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;假设有一个OA系统，该系统有3000个用户，平均每天大约有400个用户要访问该系统，对一个典型用户来说，一天之内用户从登录到退出该系统的平均时间为4小时，在一天的时间内，用户只在8小时内使用该系统。</span></p><p><span style="color: rgb(51, 51, 51);">则根据公式（1）和公式（2），可以得到：</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C = 400*4/8 = 200</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C’≈200+3*根号200 = 242&nbsp;</span></p><p><br></p><p><br></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;F=VU * R / T</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;R = T / TS</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;TS为用户思考时间</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;计算思考时间的一般步骤：</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;A、 首先计算出系统的并发用户数</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;C=nL / T&nbsp;&nbsp;&nbsp;F=R×C</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;B、 统计出系统平均的吞吐量</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;F=VU * R / T R×C = VU * R / T</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;C、 统计出平均每个用户发出的请求数量</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;R=u*C*T/VU</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;D、根据公式计算出思考时间</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;TS=T/R</span></p><p><br></p><p><br></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;缺陷检测有效性百分比DDE=TDFT/(TDFC+TDFT)×100%</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;其中:TDFT=测试过程中发现的全部缺陷(即由测试组发现的),TDFC=客户发现的全部缺陷(在版本交付后一个标准点开始测量,如,半年以后)</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;缺陷排除有效性百分比DRE=(TDCT/TDFT)×100%</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;其中:TDCT=测试中改正的全部缺陷,TDFT=测试过程中发现的全部缺陷</span></p><p><br></p><p><br></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;测试用例设计效率百分比TDE=(TDFT/NTC)×100%</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;其中:TDFT=测试过程中发现的全部缺陷,NTC=运行的测试用例数</span></p><p><br></p><p><br></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;以下公式较适用于白盒测试</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;功能覆盖率= 至少被执行一次的测试功能点数/ 测试功能点总数 （功能点）</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;需求覆盖率= 被验证到的需求数量 /总的需求数量 （需求）</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;覆盖率= 至少被执行一次的测试用例数/ 应执行的测试用例总数 （测试用例）</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;语句覆盖率= 至少被执行一次的语句数量/ 有效的程序代码行数</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;判定覆盖率= 判定结果被评价的次数 / 判定结果总数</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;条件覆盖率= 条件操作数值至少被评价一次的数量 / 条件操作数值的总数</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;判定条件覆盖率= 条件操作数值或判定结果至少被评价一次的数量/(条件操作数值总数+判定结果总数)</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;上下文判定覆盖率= 上下文内已执行的判定分支数和/(上下文数*上下文内的判定分支总数)</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;基于状态的上下文入口覆盖率= 累加每个状态内执行到的方法数/(状态数*类内方法总数)</span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;分支条件组合覆盖率= 被评测到的分支条件组合数/分支条件组合数</span></p><p>&nbsp;&nbsp;路径覆盖率= 至少被执行一次的路径数/程序总路径数</p><p><br></p>