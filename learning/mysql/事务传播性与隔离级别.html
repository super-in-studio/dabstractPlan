<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-83e49df2-8ab6-44a7-9d70-7d298b8c5477"></attachment><h2>spring事务的7种传播机制</h2><h3>1、PROPAGATION_REQUIRED</h3><p>若当前存在事务，则加入该事务，若不存在事务，则新建一个事务。</p><h3>2、PAOPAGATION_REQUIRE_NEW</h3><p>若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。</p><h3>3、PROPAGATION_NESTED</h3><p>如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，则新建一个事务，类似于REQUIRE_NEW。</p><h3>4、PROPAGATION_SUPPORTS</h3><p>支持当前事务，若当前不存在事务，以非事务的方式执行。</p><h3>5、PROPAGATION_NOT_SUPPORTED</h3><p>以非事务的方式执行，若当前存在事务，则把当前事务挂起。</p><h3>6、PROPAGATION_MANDATORY</h3><p>强制事务执行，若当前不存在事务，则抛出异常</p><h3>7、PROPAGATION_NEVER</h3><p>以非事务的方式执行，如果当前存在事务，则抛出异常。</p><p><br></p><h2>二、spring事务的四种隔离级别</h2><p><br></p><p>1、事务的四大特性（ACID）</p><p>原子性</p><p>操作要么全部成功，要么全部失败回滚。</p><p><br></p><p>一致性</p><p>事务执行前和执行后处于一致性状态。例如，转账前A、B共5000元，A、B之间转账后，两者之和仍应该是5000元。</p><p><br></p><p>隔离性</p><p>事务之间互不干扰。</p><p><br></p><p>持久性</p><p>事务一旦提交，数据的改变是永久性的，即使这时候数据库发生故障，数据也不会丢失。</p><p><br></p><p>2、与事务隔离级别的相关问题</p><p>脏读</p><p>A事务对一条记录进行修改，尚未提交，B事务已经看到了A的修改结果。若A发生回滚，B读到的数据就是错误的，这就是脏读。</p><p><br></p><p>不可重复读</p><p>A事务对一条记录进行修改，尚未提交，B事务第一次查询该记录，看到的是修改之后的结果，此时A发生回滚，B事务又一次查询该记录，看到的是回滚后的结果。同一个事务内，B两次查询结果不一致，这就是不可重复读。</p><p><br></p><p>幻读</p><p>A事务对所有记录进行修改，尚未提交，此时B事务创建了一条新记录，A、B都提交。A查看所有数据，发现有一条数据没有被修改，因为这是B事务新增的，就想看到了幻象一样，这就是幻读。</p><p><br></p><p>3、事务的隔离级别</p><p>读未提交（read uncommitted）</p><p>事务尚未提交，其他事务即可以看到该事务的修改结果。隔离级别最差，脏读、不可重复读、幻读都不能避免。</p><p><br></p><p>读提交（read committed）</p><p>事务只能看到其他事务提交之后的数据。可避免脏读，不可重复读、幻读无法避免。</p><p><br></p><p>不可重复读原因：A事务修改，B事务查询，A提交前和提交后，B事务看到的数据是不一致的。</p><p><br></p><p>幻读原因：A事务修改，B事务新增，B事务提交前，A事务已经提交。B事务提交后，A发现仍有数据未修改。</p><p><br></p><p>可重复读（repeatable read）-------innodb默认隔离级别</p><p>一个事务多次查询，无论其他事务对数据如何修改，看到的数据都是一致的。因为A事务查询数据时，若B同时在修改数据，A事务看到的永远是B事务执行前的数据。只有当A提交或者回滚之后，看到的才是最新的被B修改知乎的数据。可避免脏读、不可重复读，幻读无法避免。</p><p><br></p><p>序列化（serializable）</p><p>事务顺序执行，可避免脏读、不可重复读、幻读，但效率最差。因为A事务执行时，其他事务必须等待。</p><p><br></p><p><br></p>