<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-5829a966-6208-4b70-9b78-4665379105dd"></attachment><p>首先Mysql的基本存储结构是<strong>页</strong>(记录都存在页里边)：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a53a7920b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a53b78847?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><br></p><ul><li><strong>各个数据页</strong>可以组成一个<strong>双向链表</strong></li><li>而<strong>每个数据页中的记录</strong>又可以组成一个<strong>单向</strong>链表</li><li class="ql-indent-1">每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过<strong>主键</strong>查找某条记录的时候可以在页目录中使用<strong>二分法快速定位</strong>到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li class="ql-indent-1">以<strong>其他列</strong>(非主键)作为搜索条件：只能从最小记录开始<strong>依次遍历单链表中的每条记录</strong>。</li></ul><p>所以说，如果我们写<code>select * from user where username = 'Java3y'</code>这样没有进行任何优化的sql语句，默认会这样做：</p><p><br></p><p><br></p><ul><li>定位到记录所在的页</li><li class="ql-indent-1">需要遍历双向链表，找到所在的页</li><li>从所在的页内中查找相应的记录</li><li class="ql-indent-1">由于不是根据主键查询，只能遍历所在页的单链表了</li></ul><p>很明显，在数据量很大的情况下这样查找会<strong>很慢</strong>！</p><p><br></p><p><br></p><h2>1.2索引提高检索速度</h2><p>索引做了些什么可以让我们查询加快速度呢？</p><p>其实就是<strong>将无序的数据变成有序(相对)</strong>：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a568820c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>要找到id为8的记录简要步骤：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a5663f62b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>很明显的是：<strong>没有用索引</strong>我们是需要<strong>遍历双向链表</strong>来定位对应的页，现在通过**“目录”**就可以很快地定位到对应的页上了！</p><p>其实底层结构就是<strong>B+树</strong>，B+树作为树的一种实现，能够让我们<strong>很快地</strong>查找出对应的记录。</p><p>参考资料：</p><p><br></p><p><br></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247483701&amp;idx=1&amp;sn=bd229dd584f51ef4fe545d44ad8cdbf9&amp;chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&amp;mpshare=1&amp;scene=1&amp;srcid=0409Tn66UYWSWvqEVlOpwGtR&amp;key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&amp;ascene=0&amp;uin=MzAzMjU4NDM3Nw%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&amp;version=12020810&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0" target="_blank">Mysql索引</a></li></ul><h2>1.3索引降低增删改的速度</h2><p>B+树是<strong>平衡树</strong>的一种。</p><p><br></p><p><br></p><blockquote>平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</blockquote><p>如果一棵普通的树在<strong>极端</strong>的情况下，是能<strong>退化成链表</strong>的(树的优点就不复存在了)</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a56110d4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合<strong>矮矮胖胖(均衡)的结构</strong>)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。</p><p><br></p><p><br></p><ul><li>B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会<strong>破坏它的原有结构</strong>。</li><li><strong>要维持平衡树，就必须做额外的工作</strong>。正因为这些额外的工作<strong>开销</strong>，导致索引会降低增删改的速度</li></ul><p>B+树删除和修改具体可参考：</p><p><br></p><p><br></p><ul><li><a href="https://www.cnblogs.com/wade-luffy/p/6292784.html" target="_blank">www.cnblogs.com/wade-luffy/…</a></li></ul><h2>1.4哈希索引</h2><p>除了B+树之外，还有一种常见的是哈希索引。</p><p>哈希索引就是采用一定的<strong>哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可<strong>立刻定位到相应的位置，速度非常快</strong>。</p><p><br></p><p><br></p><ul><li>本质上就是<strong>把键值换算成新的哈希值</strong>，根据这个<strong>哈希值来定位</strong>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7a55fd52b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>看起来哈希索引很牛逼啊，但其实哈希索引有好几个局限(根据他本质的原理可得)：</p><p><br></p><p><br></p><ul><li>哈希索引也没办法利用索引完成<strong>排序</strong></li><li>不支持<strong>最左匹配原则</strong></li><li>在有大量重复键值情况下，哈希索引的效率也是极低的----&gt;<strong>哈希碰撞</strong>问题。</li><li><strong>不支持范围查询</strong></li></ul><p>参考资料：</p><p><br></p><p><br></p><ul><li><a href="http://www.cnblogs.com/zengkefu/p/5647279.html" target="_blank">www.cnblogs.com/zengkefu/p/…</a>---hash索引和b+tree索引</li></ul><h2>1.5InnoDB支持哈希索引吗？</h2><p>主流的还是使用<strong>B+树索引比较多</strong>，对于哈希索引，<strong>InnoDB是自适应哈希索引</strong>的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7ac1c13504?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>参考资料：</p><p><br></p><p><br></p><ul><li><a href="https://blog.csdn.net/doctor_who2004/article/details/77414742" target="_blank">blog.csdn.net/doctor_who2…</a></li></ul><h2>1.6聚集和非聚集索引</h2><p>简单概括：</p><p><br></p><p><br></p><ul><li>聚集索引就是以<strong>主键</strong>创建的索引</li><li>非聚集索引就是以<strong>非主键</strong>创建的索引</li></ul><p>区别：</p><p><br></p><p><br></p><ul><li>聚集索引在叶子节点存储的是<strong>表中的数据</strong></li><li>非聚集索引在叶子节点存储的是<strong>主键和索引列</strong></li><li>使用非聚集索引查询出数据时，<strong>拿到叶子上的主键再去查到想要查找的数据</strong>。(拿到主键再查找这个过程叫做<strong>回表</strong>)</li></ul><p><strong>非聚集索引也叫做二级索引</strong>，不用纠结那么多名词，将其等价就行了~</p><p>非聚集索引在建立的时候也<strong>未必是单列</strong>的，可以多个列来创建索引。</p><p><br></p><p><br></p><ul><li>此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则--&gt;后面有说)</li><li><strong>创建多个单列(非聚集)索引的时候，会生成多个索引树</strong>(所以过多创建索引会占用磁盘空间)</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6d7aca19377b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在创建多列索引中也涉及到了一种特殊的索引--&gt;<strong>覆盖索引</strong></p><p><br></p><p><br></p><ul><li>我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值</li><li>最终还是要“回表”，也就是要通过主键<strong>再</strong>查找一次。这样就会比较慢</li><li>覆盖索引就是把要<strong>查询出的列和索引是对应的</strong>，不做回表操作！</li></ul><p>比如说：</p><p><br></p><p><br></p><ul><li>现在我创建了索引<code>(username,age)</code>，在查询数据的时候：<code>select username , age from user where username = 'Java3y' and age = 20</code>。</li><li>很明显地知道，我们上边的查询是走索引的，并且，<strong>要查询出的列在叶子节点都存在</strong>！所以，就不用回表了~</li><li>所以，能使用覆盖索引就尽量使用吧~</li></ul><h2>1.7索引最左匹配原则</h2><p><strong>最左匹配原则</strong>：</p><p><br></p><p><br></p><ul><li>索引可以简单如一个列<code>(a)</code>，也可以复杂如多个列<code>(a, b, c, d)</code>，即<strong>联合索引</strong>。</li><li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询<code>(&gt;、&lt;、between、like</code>左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li><li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li></ul><p>例子：</p><p><br></p><p><br></p><ul><li>如有索引<code>(a, b, c, d)</code>，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是<strong>相等</strong>的情况，不能是范围匹配)</li></ul><p><br></p><p><br></p><p><br></p><h1>MySql中锁与索引的关系</h1><p><br></p><p><strong>InnoDB 与 MyISAM 的最大不同有两点：一是 InnoDB 支持事务；二是 InnoDB 采用了行级锁</strong>。也就是你需要修改哪行，就可以只锁定哪行。</p><p> <strong>在Mysql中，行级锁并不是直接锁记录，而是锁索引。InnoDB 行锁是通过给索引项加锁实现的</strong>，索引分为主键索引和非主键索引两种，<strong>如果一条sql 语句操作了主键索引，Mysql 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。如果没有索引，InnoDB 会通过隐藏的聚簇索引来对记录加锁。</strong>也就是说：<strong>如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表级锁一样。</strong></p><p><br></p><p><br></p>