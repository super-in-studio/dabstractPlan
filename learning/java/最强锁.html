<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-a680a058-5a30-47c4-bf92-e75c84112f98"></attachment><p>面试三连</p><p>面试官：了解锁吗？</p><p><br></p><p>小明：了解，还经常用过。</p><p><br></p><p>面试官：说说synchronized和lock的区别吧</p><p><br></p><p>小明：synchronized是可重入锁，由于lock是一个接口，重入性取决于实现，synchronized不支持中断，而lock可以。。。。。。。。。。。。。。。。</p><p><br></p><p>面试官：好了，那有没有比这两种锁更快的锁呢？</p><p><br></p><p>小明：在读多写少的情况下，读写锁比他们的效率更高。</p><p><br></p><p>面试官：那有没有比读写锁更快的锁呢？</p><p><br></p><p>小明：。。。。。。。。。。</p><p><br></p><p>我靠，问的这么深的吗？小明当时就蒙蔽了，因为它项目中使用比较多的就是synchronized，读写锁都很少用到，因为很少牵扯到多线程问题，这个面试让他知道了多线程的重要性。</p><p><br></p><p>什么是读写锁</p><p>读写锁：允许多个线程同时读，但是只允许一个线程写，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，读锁和写锁也是互斥的，所以在读的时候是不允许写的，那如何实现一个读写锁呢？</p><p><br></p><p>请参考：java并发编程之ReentrantReadWriteLock读写锁。</p><p><br></p><p>读写锁比传统的synchronized速度要快很多，原因就是在于读写锁支持读并发，而synchronized要求所有操作都是串行化，举个例子，我需要查询某个用户的基本信息，这些信息很少发生变化，所以我们会将这部分信息存放到缓存中，我们的查询操作为：</p><p><br></p><p>开始</p><p>查询缓存</p><p>缓存中是否存在数据？</p><p>结束</p><p>查询数据库</p><p>添加到缓存</p><p>yes</p><p>no</p><p>按照上面流程图，如果使用synchronized的时候，查询缓存都会阻塞，但是使用读写锁，查询缓存时并发的，查询数据库是阻塞的，所以，读写锁在读多写少的情况下，性能明显要优于synchronized。</p><p><br></p><p>人类的文明在进步，java也在进步，对知识的渴望也在不断的增加，所以我们就不断的在想这么一个问题，读写锁的读和写是互斥，那我们能不能做到读和写支持并发呢？</p><p><br></p><p><br></p><p>StampedLock横空出世</p><p>StampedLock其实是对读写锁的一种改进，它支持在读同时进行一个写操作,也就是说，它的性能将会比读写锁更快。</p><p><br></p><p>更通俗的讲就是在读锁没有释放的时候是可以获取到一个写锁，获取到写锁之后，读锁阻塞，这一点和读写锁一致，唯一的区别在于读写锁不支持在没有释放读锁的时候获取写锁。</p><p><br></p><p>StampedLock三种模式</p><p>悲观读：与读写锁的读写类似，允许多个线程获取悲观读锁</p><p>写锁：与读写锁的写锁类似，写锁和悲观读是互斥的。</p><p>乐观读：无锁机制，类似于数据库中的乐观锁，它支持在不是放写锁的时候是可以获取到一个写锁的，这点和读写锁不同。</p><p>基本语法</p><p>我们先来看看悲观读于与写锁的基本语法</p><p><br></p><p>//获取悲观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;long stamp = lock.readLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String info = mapCache.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != info){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return info;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放悲观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;stamp = lock.writeLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断一下缓存中是否被插入了数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String info = mapCache.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != info){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return info;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里是往数据库获取数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String infoByDb = mapDb.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//讲数据插入缓存</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapCache.put(name,infoByDb);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>我们看到，StampedLock语法和读写锁ReentrantReadWriteLock有了一点点区别，</p><p>获取锁的返回值：</p><p>StampedLock：long</p><p>ReentrantReadWriteLock：Lock</p><p><br></p><p>释放锁的方式：</p><p>StampedLock：unlock(stamp),需要传入获取锁返回的那个long值。</p><p>ReentrantReadWriteLock：unlock(),直接调用unlock方法即可。</p><p><br></p><p>StampedLock完整的demo</p><p>package com.ymy.test;</p><p><br></p><p><br></p><p>import java.util.HashMap;</p><p>import java.util.Map;</p><p>import java.util.concurrent.locks.StampedLock;</p><p><br></p><p>public class StampedLockTest {</p><p><br></p><p>&nbsp;&nbsp;private static final StampedLock lock = new StampedLock();</p><p><br></p><p>&nbsp;&nbsp;//缓存中存储的数据</p><p>&nbsp;&nbsp;private static Map&lt;String,String&gt; mapCache = new HashMap&lt;String, String&gt;();</p><p><br></p><p>&nbsp;&nbsp;//模拟数据库存储的数据</p><p>&nbsp;&nbsp;private static Map&lt;String,String&gt; mapDb = new HashMap&lt;String, String&gt;();</p><p>&nbsp;&nbsp;static {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;mapDb.put("zhangsan","你好，我是张三");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;mapDb.put("sili","你好，我是李四");</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;private static String getInfo(String name){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取悲观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;long stamp = lock.readLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String info = mapCache.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != info){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("在缓存中获取到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return info;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放悲观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;stamp = lock.writeLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断一下缓存中是否被插入了数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String info = mapCache.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != info){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("获取到了写锁，再次确认在缓存中获取到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return info;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里是往数据库获取数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String infoByDb = mapDb.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//讲数据插入缓存</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapCache.put(name,infoByDb);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("缓存中没有数据，在数据库获取到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return null;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public static void main(String[] args) {</p><p>//线程1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread t1 = new Thread(() -&gt;{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getInfo("zhangsan");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;});</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;//线程2</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread t2 = new Thread(() -&gt;{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getInfo("zhangsan");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;});</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;//线程启动</p><p>&nbsp;&nbsp;&nbsp;&nbsp;t1.start();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;t2.start();</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;//线程同步</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1.join();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2.join();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>&nbsp;&nbsp;}</p><p><br></p><p>}</p><p><br></p><p>这是悲观读+写锁的使用方式，达到的效果与读写锁（ReentrantReadWriteLock） 是一样的，我们一起来验证一下，我将代码稍微做了一点改动，打印了两个线程的执行日志，同时当调用线程是zhangsan的时候休眠三秒，目的是为了看lisi的线程能否成功的获取到写锁，代码如下</p><p><br></p><p>package com.ymy.test;</p><p><br></p><p><br></p><p>import java.util.HashMap;</p><p>import java.util.Map;</p><p>import java.util.concurrent.locks.StampedLock;</p><p>import java.util.logging.Logger;</p><p><br></p><p>public class StampedLockTest {</p><p><br></p><p>&nbsp;&nbsp;private static Logger log = Logger.getLogger(StampedLockTest.class.getName());</p><p><br></p><p>&nbsp;&nbsp;private static final StampedLock lock = new StampedLock();</p><p><br></p><p>&nbsp;&nbsp;//缓存中存储的数据</p><p>&nbsp;&nbsp;private static Map&lt;String,String&gt; mapCache = new HashMap&lt;String, String&gt;();</p><p><br></p><p>&nbsp;&nbsp;//模拟数据库存储的数据</p><p>&nbsp;&nbsp;private static Map&lt;String,String&gt; mapDb = new HashMap&lt;String, String&gt;();</p><p>&nbsp;&nbsp;static {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;mapDb.put("zhangsan","你好，我是张三");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;mapDb.put("sili","你好，我是李四");</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;private static String getInfo(String name){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取悲观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;long stamp = lock.readLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;log.info("线程名："+Thread.currentThread().getName()+" 获取了悲观读锁"&nbsp;+"&nbsp;&nbsp;用户名："+name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if("zhangsan".equals(name)){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("线程名："+Thread.currentThread().getName()+" 休眠中"&nbsp;+"&nbsp;&nbsp;用户名："+name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(3000);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("线程名："+Thread.currentThread().getName()+" 休眠结束"&nbsp;+"&nbsp;&nbsp;用户名："+name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String info = mapCache.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != info){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("在缓存中获取到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return info;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("线程名："+Thread.currentThread().getName()+" 释放了悲观读锁");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放悲观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;stamp = lock.writeLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;log.info("线程名："+Thread.currentThread().getName()+" 获取了写锁"&nbsp;+"&nbsp;&nbsp;用户名："+name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断一下缓存中是否被插入了数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String info = mapCache.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != info){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("获取到了写锁，再次确认在缓存中获取到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return info;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这里是往数据库获取数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String infoByDb = mapDb.get(name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//讲数据插入缓存</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapCache.put(name,infoByDb);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("缓存中没有数据，在数据库获取到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("线程名："+Thread.currentThread().getName()+" 释放了写锁" +"&nbsp;&nbsp;&nbsp;用户名："+name);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return null;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public static void main(String[] args) {</p><p>//线程1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread t1 = new Thread(() -&gt;{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getInfo("zhangsan");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;});</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;//线程2</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread t2 = new Thread(() -&gt;{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getInfo("lisi");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;});</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;//线程启动</p><p>&nbsp;&nbsp;&nbsp;&nbsp;t1.start();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;t2.start();</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;//线程同步</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1.join();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2.join();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>&nbsp;&nbsp;}</p><p><br></p><p>}</p><p><br></p><p><br></p><p>如果在zhansan的线程休眠阶段李四的线程获取到了写锁，那么代表悲观读和写锁不是互斥的，反之互斥，请看代码运行结果：</p><p><br></p><p>三月 29, 2020 11:30:58 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-2 获取了悲观读锁&nbsp;&nbsp;用户名：lisi</p><p>三月 29, 2020 11:30:58 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-1 获取了悲观读锁&nbsp;&nbsp;用户名：zhangsan</p><p>三月 29, 2020 11:30:58 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-1 休眠中&nbsp;&nbsp;用户名：zhangsan</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-1 休眠结束&nbsp;&nbsp;用户名：zhangsan</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-1 获取了写锁&nbsp;&nbsp;用户名：zhangsan</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 缓存中没有数据，在数据库获取到了数据</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-1 释放了写锁&nbsp;&nbsp;&nbsp;用户名：zhangsan</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-2 获取了写锁&nbsp;&nbsp;用户名：lisi</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 缓存中没有数据，在数据库获取到了数据</p><p>三月 29, 2020 11:31:01 上午 com.ymy.test.StampedLockTest getInfo</p><p>信息: 线程名：Thread-2 释放了写锁&nbsp;&nbsp;&nbsp;用户名：lisi</p><p><br></p><p>我们仔细看打印日志的输出时间， 11:30:58 lisi和zhangsan都获取到了悲观读锁，并且zhangsan开始休眠，然后11:31:01的时候休眠结束，zhangsan获取到了写锁，所以悲观读与写锁肯定是互斥的，那这样的效率不是和读写锁一样吗？为什么说它比读写锁更快呢？这不是矛盾吗？</p><p><br></p><p>客官，别急啊，要记住精彩的永远在最后，StampedLock特锁模式我们只用了其中的两个，还有一个没有出场呢，下面我们来看看乐观读。</p><p><br></p><p>让StampedLock性能更上一楼的乐观读</p><p>乐观读并不是一种锁，所以请不要和悲观读联系在一起，它是一种无锁机制，相当于java的原子类操作，所以理论上性能会比读写锁（ReentrantReadWriteLock）更快一点，但不绝对。</p><p><br></p><p>当乐观读读取了成员变量的时候，需要将变量赋值给局部变量，然后再判断程序运行期间是否存在写锁，如果存在，升级为悲观读。</p><p><br></p><p>我们一起来看一下乐观读的实现</p><p><br></p><p>package com.ymy.test;</p><p><br></p><p>import java.util.concurrent.locks.StampedLock;</p><p><br></p><p>public class NumSumTest {</p><p><br></p><p>&nbsp;&nbsp;private static final StampedLock lock = new StampedLock();</p><p><br></p><p><br></p><p>&nbsp;&nbsp;private static int num1 = 1;</p><p><br></p><p><br></p><p>&nbsp;&nbsp;private static int num2 = 1;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 修改成员变量的值，+1</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private static int sum() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("求和方法被执行了");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取乐观读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;long stamp = lock.tryOptimisticRead();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;int cnum1 = num1;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;int cnum2 = num2;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("获取到的成员变量值,cnum1：" + cnum1 + "&nbsp;&nbsp;cnum2：" + cnum2);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//休眠3秒，目的是为了让其他线程修改掉成员变量的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(3000);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//判断在运行期间是否存在写操作&nbsp;&nbsp;true：不存在&nbsp;&nbsp;false:存在</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (!lock.validate(stamp)) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("存在写操作！");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//存在写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//升级悲观读锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stamp = lock.readLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("升级悲观读锁");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnum1 = num1;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnum2 = num2;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("重新获取了成员变量的值=========== cnum1="+cnum1&nbsp;+"&nbsp;&nbsp;cnum2="+cnum2);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放悲观读锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cnum1 + cnum2;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;//使用写锁修改成员变量的值</p><p>&nbsp;&nbsp;private static void updateNum() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;long stamp = lock.writeLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num1 = 2;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num2 = 2;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock(stamp);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>&nbsp;&nbsp;public static void main(String[] args) throws InterruptedException {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread t1 = new Thread(() -&gt; {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int sum = sum();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("求和结果：" + sum);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;t1.start();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//休眠1秒，目的为了让线程t1能执行到获取成员变量之后</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(1000);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;updateNum();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;t1.join();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("执行完毕");</p><p><br></p><p>&nbsp;&nbsp;}</p><p><br></p><p>}</p><p><br></p><p><br></p><p><br></p><p>解释代码，定义了两个成员变量，让后利用t1线程去计算两个成员变量的和，为了能体现出乐观读的效果，我在sum()中休眠了3秒，目的是让main主线程去修改掉成员变量的值，main函数中的休眠是为了让t1线程能准确地执行到读取成员变量阶段。</p><p><br></p><p>我们来看看执行的结果：</p><p><br></p><p>求和方法被执行了</p><p>获取到的成员变量值,cnum1：1&nbsp;&nbsp;cnum2：1</p><p>存在写操作！</p><p>升级悲观读锁</p><p>重新获取了成员变量的值=========== cnum1=2&nbsp;&nbsp;cnum2=2</p><p>求和结果：4</p><p>执行完毕</p><p><br></p><p><br></p><p>我们发现，t1首先读取了两个成员变量的值，然后发现了存在写操作，那是因为main函数利用写锁修改了两个成员变量的值，这个时候升级为了悲观读，再次获取成员变量的值，然后再计算两个值的和，为什么要升级悲观读锁呢？因为再文章开头的时候说过悲观读锁与写锁互斥，悲观读锁之前并行，所以乐观读升级到悲观读锁之后再获取一次成员变量，可以保证再当前悲观读锁中数据是线程安全的。</p><p><br></p><p>你了解乐观读的应用场景吗</p><p>乐观读并不是StampedLock的专利，有很多地方都使用到了乐观读，比如数据库的乐观锁悲观锁，java并发工具的原子类工具。</p><p><br></p><p>数据库悲观锁与乐观锁可以参考：mysql：悲观锁与乐观锁</p><p><br></p><p>java 并发工具原子类参考：java并发编程：CAS(Compare and Swap)</p><p><br></p><p>使用StampedLock的注意事项</p><p>1.StampedLock属于ReadWriteLock的子类，ReentrantReadWriteLock也是属于ReadWriteLock的子类，你们发现他们的区别了吗？看名字就能看出来StampedLock不支持重入锁。</p><p><br></p><p>2.它适用于读多写少的情况，如果不是这中情况，请慎用，性能可能还不如synchronized。</p><p><br></p><p>3.StampedLock的悲观读锁、写锁不支持条件变量。</p><p><br></p><p>4.千万不能中断阻塞的悲观读锁或写锁，如果调用阻塞线程的interrupt()，会导致cpu飙升，如果希望StampedLock支持中断操作，请使用readLockInterruptibly（悲观读锁）与writeLockInterruptibly（写锁）。</p><p><br></p><p>总结</p><p>在读多写少的情况下推荐使用StampedLock，因为它的乐观读，性能比读写锁提升了很多，但是再其他应用场景中，使用它还需要慎重。</p><p><br></p><p>乐观读支持并发一个写锁，而悲观读和写锁互斥，所以在使用过程中，我们可以先使用乐观读。然后判断是否存在写锁，如果存在，可以升级悲观读锁，由于悲观读锁和写锁的互斥性，他能保证线程的安全性问题，如果小明再平时的时候多看看我的博客的话，可能就不会被这个问题难住了。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「卖托儿索的小火柴」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：https://blog.csdn.net/qq_33220089/java/article/details/105173632</p><p><br></p>