<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-2e10f769-a994-425b-8994-cc0996a77542"></attachment><p>1.mirror GC</p><p>(1)<span style="color: rgb(61, 70, 77);">当Eden区满了的时候，会触发</span>mirror <span style="color: rgb(61, 70, 77);">GC</span></p><p><br></p><p><span style="color: rgb(61, 70, 77);">2.什么时候会发生Full GC</span></p><h2>(1)System.gc()方法的调用</h2><h2>(2)老年代空间不足</h2><h2>(3)永生区空间不足</h2><h2>(4)CMS GC时出现promotion failed和concurrent mode failure</h2><ul><li><span style="color: rgb(51, 51, 51);">promotion failed是在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，这时如果新生代要转移到老年带的对象比较大，所以，必须</span><span style="color: rgb(255, 0, 0);">尽可能提早触发老年代的CMS回收</span><span style="color: rgb(51, 51, 51);">来避免这个问题</span></li><li><span style="color: rgb(51, 51, 51);">concurrent mode failure是在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。</span></li></ul><p><br></p><h2>(5)HandlePromotionFailure</h2><ul><li><span style="color: rgb(77, 77, 77);">在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</span></li></ul><p><br></p>