<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-2e10f769-a994-425b-8994-cc0996a77542"></attachment><p>1.mirror GC</p><p>(1)<span style="color: rgb(61, 70, 77);">当Eden区满了的时候，会触发</span>mirror <span style="color: rgb(61, 70, 77);">GC</span></p><p><br></p><p><span style="color: rgb(61, 70, 77);">2.什么时候会发生Full GC</span></p><h2>(1)System.gc()方法的调用</h2><h2>(2)老年代空间不足</h2><h2>(3)永生区空间不足</h2><h2>(4)堆中分配很大的对象</h2><p>所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。</p><h2>为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的</h2><p><br></p>