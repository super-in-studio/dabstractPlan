<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-2e10f769-a994-425b-8994-cc0996a77542"></attachment><p>1.mirror GC</p><p>(1)<span style="color: rgb(61, 70, 77);">当Eden区满了的时候，会触发</span>mirror <span style="color: rgb(61, 70, 77);">GC</span></p><p><br></p><p><span style="color: rgb(61, 70, 77);">2.什么时候会发生Full GC</span></p><h2>(1)System.gc()方法的调用</h2><h2>(2)老年代空间不足</h2><h2>(3)永生区空间不足</h2><h2>(4)CMS GC时出现promotion failed和concurrent mode failure</h2><ul><li><span style="color: rgb(51, 51, 51);">promotion failed是在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，这时如果新生代要转移到老年带的对象比较大，所以，必须</span><span style="color: rgb(255, 0, 0);">尽可能提早触发老年代的CMS回收</span><span style="color: rgb(51, 51, 51);">来避免这个问题</span></li><li><span style="color: rgb(51, 51, 51);">concurrent mode failure是在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。</span></li></ul><p><br></p><h2>(5)堆中分配很大的对象</h2><p>所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。</p><h2>为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的</h2><p><br></p>