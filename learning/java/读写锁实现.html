<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-5871130e-6ada-42ec-8098-c1f165ed21e7"></attachment><p>synchronized</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个关键字，是锁的意思，而且还是一种可重入锁，使用它可以保证线程的互斥性，保证被synchronized修饰的代码块或者方法在同一时刻只能被一个线程访问，所以在并发编程中可以保证数据的准确性，由于他是锁住了整个代码块或者方法，这样就会大大的降低程序的性能，在并发很高的时候会导致很卡。</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;那有没有比synchronized更快的锁呢？java这么强大，肯定是有的，那就是今天的主角：ReentrantReadWriteLock，读写锁，</p><p><br></p><p>介绍读写锁之前我们先看一个普通的程序：</p><p><br></p><p>&nbsp;public&nbsp;User getUserInfo(){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//从缓存中获取数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;User user = (User) redisTemplate.opsForValue().get("user");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if(null != user){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("在缓存中拿到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return user;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;log.info("缓存中没有数据，往数据库获取");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//缓存中没有数据，从数据库捞取数据(这里我就不去数据库拿了，直接用map集合模拟)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;user = map.get("user");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if(null != user){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将数据存到缓存中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.opsForValue().set("user",user);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return user;</p><p>&nbsp;</p><p>&nbsp;&nbsp;}</p><p>这是一个获取用户信息的方法，模拟了先从缓存中获取数据，如果缓存中不存在，则向数据库中获取，这段代码看起来因该是没有任何问题，但事实是这样吗？</p><p><br></p><p>我们来测试一下，使用jmeter做并发测试：</p><p><br></p><p><br></p><p><br></p><p>模拟一百个线程同时访问，结果会是如何呢?请看下图：</p><p><br></p><p><br></p><p><br></p><p>&nbsp;</p><p><br></p><p>看到没有，居然会有8次访问走到了数据库，这就是我们经常提到的线程安全问题，在生产环境中肯定是不允许这样的事情发生，如何避免呢，可以在方法名加上synchronized关键字，这个确实能保证线程安全，但是性能不会很好，所以我们可以使用性能更好的ReentrantReadWriteLock（读写锁）。</p><p><br></p><p>读写锁，顾名思义，读的时候一把锁，写的时候一把锁，为什么两把锁的性能还会比synchronized的一把锁性能更好的呢？</p><p><br></p><p>那是因为ReentrantReadWriteLock的读锁是可以支持并发的，所以向刚刚上面的哪个例子，读多写少的情况家，非常推荐读写锁，虽然读锁是支持并发，但是写锁依然保持线程的互斥，并且在获取写锁之后，读锁也会暂时处于阻塞状态，等待释放写锁。</p><p><br></p><p>好了，废话不多，我们来看看如何实现，上代码：</p><p><br></p><p>package com.ymy.service;</p><p>&nbsp;</p><p>import com.ymy.entity.User;</p><p>import lombok.extern.slf4j.Slf4j;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.data.redis.core.RedisTemplate;</p><p>import org.springframework.stereotype.Service;</p><p>&nbsp;</p><p>import java.util.Map;</p><p>import java.util.concurrent.ConcurrentHashMap;</p><p>import java.util.concurrent.locks.Lock;</p><p>import java.util.concurrent.locks.ReadWriteLock;</p><p>import java.util.concurrent.locks.ReentrantReadWriteLock;</p><p>&nbsp;</p><p>@Service</p><p>@Slf4j</p><p>public class ReadWriteLockService {</p><p>&nbsp;</p><p>&nbsp;&nbsp;@Autowired</p><p>&nbsp;&nbsp;private RedisTemplate redisTemplate;</p><p>&nbsp;</p><p>&nbsp;&nbsp;private static Map&lt;String,User&gt; map = new ConcurrentHashMap&lt;String,User&gt;();</p><p>&nbsp;</p><p>&nbsp;&nbsp;static {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;User user = User.builder().id(1).userName("独孤求败").age(20).build();</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;map.put("user",user);</p><p>&nbsp;&nbsp;}</p><p>&nbsp;</p><p>&nbsp;&nbsp;public&nbsp;User getUserInfo(){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//实例化读写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取读锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Lock readLock =readWriteLock.readLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;User user = null;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readLock.lock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从缓存中获取数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user = (User) redisTemplate.opsForValue().get("user");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放读锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readLock.unlock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if(null != user){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("在缓存中拿到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return user;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//获取写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Lock writeLock = readWriteLock.writeLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeLock.lock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//再往缓存中获取一次，防止在加写锁的时候数据被更新</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user = (User) redisTemplate.opsForValue().get("user");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null == user){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("缓存中没有数据，往数据库获取");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//缓存中没有数据，从数据库捞取数据(这里我就不去数据库拿了，直接用map集合模拟)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user = map.get("user");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != user){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将数据存到缓存中</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.opsForValue().set("user",user);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info("在缓存中拿到了数据");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//释放写锁</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeLock.unlock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return user;</p><p>&nbsp;</p><p>&nbsp;&nbsp;}</p><p>}</p><p>加上读写锁之后会发生什么呢？同样用jmeter模拟一百次并发，结果如下：</p><p><br></p><p><br></p><p><br></p><p>为什么加了读写锁之后还是在数据库中读取了8次呢？其实这里就牵涉到锁的一个小特性，那就是加锁的对象</p><p><br></p><p>请看这行代码：</p><p><br></p><p><br></p><p><br></p><p>实例化读写锁，很明显问题就出现在这里，为什么呢？因为lock锁住的是当前实例，然后每次进入这个方法的时候都会产生一个新的实例对象，所以每次加锁的对象都不一样，怎么能实现我们想要的效果呢？</p><p><br></p><p>我们只需要做一下小小的改动即可：</p><p><br></p><p><br></p><p><br></p><p>那就是让读写锁只实例化一次就可以了，这样就能保证锁住的就是同一个对象，我们来看结果：</p><p><br></p><p><br></p><p><br></p><p>成功了，完美的做到了第一次在数据库中获取，第二次以后在缓存中获取，ReentrantReadWriteLock和synchronized一样，是可重入锁，最后在补充一句：ReentrantReadWriteLock虽然支持并发读操作，但是当某个线程获取到读锁的时候，写操作是需要处于阻塞状态。</p><p><br></p><p>那能不能在获取到读锁之后让写操作不处于阻塞状态呢？肯定是有的，StampedLock，比读写锁更快的一种锁，因为他支持在获取读锁的同时支持一个写操作。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「卖托儿索的小火柴」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：https://blog.csdn.net/qq_33220089/java/article/details/102754036</p><p><br></p>