<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-7e2102df-d72f-47f2-a74d-b3e0ba898af4"></attachment><p>package com.lxtx.hello.common.manager;</p><p><br></p><p>import java.util.concurrent.ConcurrentHashMap;</p><p>import java.util.concurrent.ConcurrentMap;</p><p>import java.util.concurrent.TimeUnit;</p><p><br></p><p>import org.springframework.beans.factory.DisposableBean;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.context.ApplicationEventPublisher;</p><p>import org.springframework.context.ApplicationEventPublisherAware;</p><p>import org.springframework.data.redis.core.RedisTemplate;</p><p>import org.springframework.transaction.support.TransactionSynchronizationManager;</p><p><br></p><p>import com.lxtx.hello.common.event.UnLockRedisEvent;</p><p>import com.lxtx.hello.common.utils.lock.LxtxLock;</p><p>import com.lxtx.hello.common.utils.lock.RedisLock;</p><p><br></p><p>import lombok.extern.slf4j.Slf4j;</p><p>@Slf4j</p><p>public class RedisLockManager implements LockManager,ApplicationEventPublisherAware,DisposableBean {</p><p>	</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 锁列表</p><p>&nbsp;&nbsp;&nbsp;* 元素为 &lt;key,LxtxLock&gt;</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>	private&nbsp;ConcurrentMap&lt;String, LxtxLock&gt; locks = new ConcurrentHashMap&lt;String, LxtxLock&gt;();</p><p>	@Autowired</p><p>	private RedisTemplate redisTemplate;</p><p>	</p><p>	private&nbsp;ApplicationEventPublisher applicationEventPublisher ;</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 创建锁</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>	public&nbsp;RedisLock createLock(String key, long time) {</p><p>		RedisLock lock = new RedisLock(redisTemplate,key,time) ;</p><p>		locks.put(key, lock) ;</p><p>		return lock;</p><p>	}</p><p><br></p><p>	public&nbsp;void unLock(String key) {</p><p>		LxtxLock lock = locks.get(key) ;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if(lock != null){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean flag = TransactionSynchronizationManager.isActualTransactionActive();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (flag) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	applicationEventPublisher.publishEvent(new UnLockRedisEvent((RedisLock)lock,key));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.warn("当前调用解锁的方法未开启事务，改用unlock方法，{}", key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;locks.remove(key) ;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;</p><p>	}</p><p>	</p><p>	/**</p><p>&nbsp;&nbsp;&nbsp;* 是否被锁：true 为锁定，false为没锁</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>	public&nbsp;boolean getLockStatus(String key) {</p><p>		LxtxLock lock = locks.get(key) ;</p><p>		return lock.isLocked();</p><p>	}</p><p>&nbsp;&nbsp;&nbsp;</p><p>	/**</p><p>&nbsp;&nbsp;&nbsp;* 上锁：true 为锁定成功，false为锁失败</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>	public&nbsp;boolean lock(String key) {</p><p>		LxtxLock lock = locks.get(key) ;</p><p>		return lock.tryLock();</p><p>	}</p><p>&nbsp;&nbsp;&nbsp;</p><p>	/**</p><p>&nbsp;&nbsp;&nbsp;* 重复上锁：true 为锁定成功，false为锁失败</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>	public&nbsp;boolean tryLock(String key, long time,TimeUnit unit) throws InterruptedException {</p><p>		LxtxLock lock = locks.get(key) ;</p><p>		return lock.tryLock(time, unit);</p><p>	}</p><p><br></p><p>	public&nbsp;RedisLock getLock(String key) {</p><p>		RedisLock lock = (RedisLock) locks.get(key) ;</p><p>		return lock;</p><p>	}</p><p>&nbsp;&nbsp;&nbsp;</p><p>	/**</p><p>	 * 服务正常停止时将锁全部解掉</p><p>	 */</p><p>	@Override</p><p>	public void destroy() throws Exception {</p><p>		log.info("关闭应用");</p><p>		for(String key : locks.keySet()){</p><p>			redisTemplate.delete(key) ;</p><p>		}</p><p>	}</p><p>	</p><p>	@Override</p><p>	public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {</p><p>		this.applicationEventPublisher = applicationEventPublisher ;</p><p>	}</p><p><br></p><p><br></p><p><br></p><p>}</p><p><br></p>