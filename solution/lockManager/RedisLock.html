<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-6886a2bc-7cad-4500-8048-a931cf2e49fe"></attachment><p>package com.lxtx.hello.common.utils.lock;</p><p><br></p><p>import java.util.ArrayList;</p><p>import java.util.List;</p><p>import java.util.UUID;</p><p>import java.util.concurrent.TimeUnit;</p><p>import java.util.concurrent.locks.Condition;</p><p><br></p><p>import org.apache.commons.lang3.StringUtils;</p><p>import org.springframework.data.redis.core.RedisCallback;</p><p>import org.springframework.data.redis.core.RedisTemplate;</p><p>import org.springframework.transaction.support.TransactionSynchronizationManager;</p><p><br></p><p>import com.alibaba.fastjson.JSON;</p><p>import com.lxtx.hello.common.event.UnLockRedisEvent;</p><p>import com.lxtx.hello.common.exception.RedisLockException;</p><p>import com.lxtx.hello.common.utils.event.EvenPublishUtils;</p><p><br></p><p>import lombok.extern.slf4j.Slf4j;</p><p>import redis.clients.jedis.Jedis;</p><p>import redis.clients.jedis.JedisCluster;</p><p><br></p><p>/**</p><p>&nbsp;* redis锁</p><p>&nbsp;*</p><p>&nbsp;* &lt;p&gt; e.g.</p><p>&nbsp;* RedisLock lock = new RedisLock(jedisCluster, "test", 60 * 1000);</p><p>&nbsp;* try {</p><p>&nbsp;* if (lock.tryLock(30, TimeUnit.SECONDS)) {</p><p>&nbsp;* // ...</p><p>&nbsp;* }</p><p>&nbsp;* } finally {</p><p>&nbsp;* lock.unLock();</p><p>&nbsp;* }</p><p>&nbsp;* &lt;p/&gt;</p><p>&nbsp;*</p><p>&nbsp;* @since 2019-04-01</p><p>&nbsp;*/</p><p>@SuppressWarnings("Duplicates")</p><p>@Slf4j</p><p>public class RedisLock implements LxtxLock {</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 两次锁请求之间的间隔时间，20毫秒</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private static final int DEFAULT_ACQUIRY_RESOLUTION_MILLIS = 20;</p><p><br></p><p>&nbsp;&nbsp;private static final String LOCK_SUCCESS = "OK";</p><p>&nbsp;&nbsp;private static final String SET_IF_NOT_EXIST = "NX";</p><p>&nbsp;&nbsp;private static final String SET_WITH_EXPIRE_TIME = "PX";</p><p>&nbsp;&nbsp;private static final Long RELEASE_SUCCESS = 1L;</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* redis lockKey</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private String lockKey;</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* redis lockKey 超时时间，单位毫秒， 这里强制加上</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private long expire;</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 解锁用，uuid一致才允许解锁</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private String uuid = UUID.randomUUID().toString().replace("-", "");</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 是否加锁成功</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private boolean isLocked = false;</p><p>&nbsp;&nbsp;private RedisTemplate redisTemplate;</p><p>&nbsp;&nbsp;private static String unlockRedisScript = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Spring 事件发送工具</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private static EvenPublishUtils evenPublishUtils;</p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;public RedisLock(RedisTemplate redisTemplate, String key, long expire) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (StringUtils.isBlank(key)) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new RedisLockException("key不能为空！");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.redisTemplate = redisTemplate;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.lockKey = key;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this.expire = expire;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public void lock() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lockInterruptibly();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error("redisLock error", e);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public void lockInterruptibly() throws InterruptedException {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;while (!isLocked) {</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = jedis.set(lockKey, uuid, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expire);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean bool = redisTemplate.opsForValue().setIfAbsent(lockKey, uuid, expire, TimeUnit.MILLISECONDS);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bool) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLocked = true;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public boolean tryLock() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean bool = redisTemplate.opsForValue().setIfAbsent(lockKey, uuid, expire, TimeUnit.MILLISECONDS);</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bool) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLocked = true;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.debug("redis tryLock error:{}", e.getMessage());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;return isLocked;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public boolean tryLock(long time, TimeUnit unit) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long retryTime = unit.toMillis(time);</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 如果重试时间太短，不重试</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long timeout = retryTime - DEFAULT_ACQUIRY_RESOLUTION_MILLIS;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timeout &lt; 0) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLocked = tryLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return isLocked;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (timeout &gt;= 0) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLocked = tryLock();</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isLocked) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 睡眠</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout -= DEFAULT_ACQUIRY_RESOLUTION_MILLIS;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error("redisLock error", e);</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new RedisLockException("获取redis锁失败! key=" + lockKey);</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new RedisLockException(LocaleUtils.getMessage("errors.try.again"));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!isLocked) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.warn("获取{}锁失败！", lockKey);</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new RedisLockException(LocaleUtils.getMessage("errors.try.again"));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;return isLocked;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public void unlock() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (isLocked) {</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(uuid));</p><p><br></p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object result = redisTemplate.execute(unlockRedisScript, Arrays.asList(lockKey), uuid);</p><p>//</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (RELEASE_SUCCESS.equals(result)) {</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLocked =&nbsp;false;</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; keys = new ArrayList&lt;&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; args = new ArrayList&lt;&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys.add(lockKey);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.add(JSON.toJSONString(uuid));</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisCallback&lt;Long&gt; callback = (connection) -&gt; {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object nativeConnection = connection.getNativeConnection();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 集群模式和单机模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 集群模式</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nativeConnection instanceof JedisCluster) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (Long) ((JedisCluster) nativeConnection).eval(unlockRedisScript, keys, args);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 单机模式</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (nativeConnection instanceof Jedis) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (Long) ((Jedis) nativeConnection).eval(unlockRedisScript, keys, args);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0L;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Long result = (Long) redisTemplate.execute(callback);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (RELEASE_SUCCESS.equals(result)) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLocked = false;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error("unlock error", e);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public Condition newCondition() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return null;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;@Override</p><p>&nbsp;&nbsp;public boolean isLocked() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return isLocked;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;* 解除redis 锁 当事务完成时&nbsp;</p><p>&nbsp;&nbsp;* 事务中解锁监听器 @UnLockRedisTransactionCompleteListener</p><p>&nbsp;&nbsp;* 无事务直接解锁</p><p>&nbsp;&nbsp;* @param redisLock</p><p>&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public static void smartUnLock(RedisLock redisLock){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if(redisLock != null){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean flag = TransactionSynchronizationManager.isActualTransactionActive();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (flag) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化spring事件发送工具</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evenPublishUtils = EvenPublishUtils.getInstance() ;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evenPublishUtils.publishUnLockRedisEvent(new UnLockRedisEvent(redisLock,redisLock.lockKey));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.warn("当前调用解锁的方法未开启事务，改用unlock方法，{}", redisLock.lockKey);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redisLock.unlock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p>}</p><p><br></p>