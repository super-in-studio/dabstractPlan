<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-0b647921-1ea3-408f-9721-1fd866388056"></attachment><p>/*</p><p>&nbsp;* Licensed to the Apache Software Foundation (ASF) under one</p><p>&nbsp;* or more contributor license agreements.&nbsp;See the NOTICE file</p><p>&nbsp;* distributed with this work for additional information</p><p>&nbsp;* regarding copyright ownership.&nbsp;The ASF licenses this file</p><p>&nbsp;* to you under the Apache License, Version 2.0 (the</p><p>&nbsp;* "License"); you may not use this file except in compliance</p><p>&nbsp;* with the License.&nbsp;You may obtain a copy of the License at</p><p>&nbsp;*</p><p>&nbsp;*&nbsp;&nbsp;&nbsp;http://www.apache.org/licenses/LICENSE-2.0</p><p>&nbsp;*</p><p>&nbsp;* Unless required by applicable law or agreed to in writing,</p><p>&nbsp;* software distributed under the License is distributed on an</p><p>&nbsp;* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</p><p>&nbsp;* KIND, either express or implied.&nbsp;See the License for the</p><p>&nbsp;* specific language governing permissions and limitations</p><p>&nbsp;* under the License.</p><p>&nbsp;*/</p><p>package org.apache.shiro.util;</p><p><br></p><p>import java.lang.ref.ReferenceQueue;</p><p>import java.lang.ref.SoftReference;</p><p>import java.util.*;</p><p>import java.util.concurrent.ConcurrentHashMap;</p><p>import java.util.concurrent.ConcurrentLinkedQueue;</p><p>import java.util.concurrent.locks.ReentrantLock;</p><p><br></p><p><br></p><p>/**</p><p>&nbsp;* A &lt;code&gt;&lt;em&gt;Soft&lt;/em&gt;HashMap&lt;/code&gt; is a memory-constrained map that stores its &lt;em&gt;values&lt;/em&gt; in</p><p>&nbsp;* {@link SoftReference SoftReference}s.&nbsp;(Contrast this with the JDK's</p><p>&nbsp;* {@link WeakHashMap WeakHashMap}, which uses weak references for its &lt;em&gt;keys&lt;/em&gt;, which is of little value if you</p><p>&nbsp;* want the cache to auto-resize itself based on memory constraints).</p><p>&nbsp;* &lt;p/&gt;</p><p>&nbsp;* Having the values wrapped by soft references allows the cache to automatically reduce its size based on memory</p><p>&nbsp;* limitations and garbage collection.&nbsp;This ensures that the cache will not cause memory leaks by holding strong</p><p>&nbsp;* references to all of its values.</p><p>&nbsp;* &lt;p/&gt;</p><p>&nbsp;* This class is a generics-enabled Map based on initial ideas from Heinz Kabutz's and Sydney Redelinghuys's</p><p>&nbsp;* &lt;a href="http://www.javaspecialists.eu/archive/Issue015.html"&gt;publicly posted version (with their approval)&lt;/a&gt;, with</p><p>&nbsp;* continued modifications.</p><p>&nbsp;* &lt;p/&gt;</p><p>&nbsp;* This implementation is thread-safe and usable in concurrent environments.</p><p>&nbsp;*</p><p>&nbsp;* @since 1.0</p><p>&nbsp;*/</p><p>public class SoftHashMap&lt;K, V&gt; implements Map&lt;K, V&gt; {</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* The default value of the RETENTION_SIZE attribute, equal to 100.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private static final int DEFAULT_RETENTION_SIZE = 100;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* The internal HashMap that will hold the SoftReference.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private final Map&lt;K, SoftValue&lt;V, K&gt;&gt; map;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* The number of strong references to hold internally, that is, the number of instances to prevent</p><p>&nbsp;&nbsp;&nbsp;* from being garbage collected automatically (unlike other soft references).</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private final int RETENTION_SIZE;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* The FIFO list of strong references (not to be garbage collected), order of last access.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private final Queue&lt;V&gt; strongReferences; //guarded by 'strongReferencesLock'</p><p>&nbsp;&nbsp;private final ReentrantLock strongReferencesLock;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Reference queue for cleared SoftReference objects.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private final ReferenceQueue&lt;? super V&gt; queue;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Creates a new SoftHashMap with a default retention size size of</p><p>&nbsp;&nbsp;&nbsp;* {@link #DEFAULT_RETENTION_SIZE DEFAULT_RETENTION_SIZE} (100 entries).</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @see #SoftHashMap(int)</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public SoftHashMap() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this(DEFAULT_RETENTION_SIZE);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Creates a new SoftHashMap with the specified retention size.</p><p>&nbsp;&nbsp;&nbsp;* &lt;p/&gt;</p><p>&nbsp;&nbsp;&nbsp;* The retention size (n) is the total number of most recent entries in the map that will be strongly referenced</p><p>&nbsp;&nbsp;&nbsp;* (ie 'retained') to prevent them from being eagerly garbage collected.&nbsp;That is, the point of a SoftHashMap is to</p><p>&nbsp;&nbsp;&nbsp;* allow the garbage collector to remove as many entries from this map as it desires, but there will always be (n)</p><p>&nbsp;&nbsp;&nbsp;* elements retained after a GC due to the strong references.</p><p>&nbsp;&nbsp;&nbsp;* &lt;p/&gt;</p><p>&nbsp;&nbsp;&nbsp;* Note that in a highly concurrent environments the exact total number of strong references may differ slightly</p><p>&nbsp;&nbsp;&nbsp;* than the actual &lt;code&gt;retentionSize&lt;/code&gt; value.&nbsp;This number is intended to be a best-effort retention low</p><p>&nbsp;&nbsp;&nbsp;* water mark.</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param retentionSize the total number of most recent entries in the map that will be strongly referenced</p><p>&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(retained), preventing them from being eagerly garbage collected by the JVM.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;@SuppressWarnings({"unchecked"})</p><p>&nbsp;&nbsp;public SoftHashMap(int retentionSize) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;super();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;RETENTION_SIZE = Math.max(0, retentionSize);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;queue = new ReferenceQueue&lt;V&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;strongReferencesLock = new ReentrantLock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;map = new ConcurrentHashMap&lt;K, SoftValue&lt;V, K&gt;&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;strongReferences = new ConcurrentLinkedQueue&lt;V&gt;();</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Creates a {@code SoftHashMap} backed by the specified {@code source}, with a default retention</p><p>&nbsp;&nbsp;&nbsp;* size of {@link #DEFAULT_RETENTION_SIZE DEFAULT_RETENTION_SIZE} (100 entries).</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param source the backing map to populate this {@code SoftHashMap}</p><p>&nbsp;&nbsp;&nbsp;* @see #SoftHashMap(Map,int)</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public SoftHashMap(Map&lt;K, V&gt; source) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this(DEFAULT_RETENTION_SIZE);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;putAll(source);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Creates a {@code SoftHashMap} backed by the specified {@code source}, with the specified retention size.</p><p>&nbsp;&nbsp;&nbsp;* &lt;p/&gt;</p><p>&nbsp;&nbsp;&nbsp;* The retention size (n) is the total number of most recent entries in the map that will be strongly referenced</p><p>&nbsp;&nbsp;&nbsp;* (ie 'retained') to prevent them from being eagerly garbage collected.&nbsp;That is, the point of a SoftHashMap is to</p><p>&nbsp;&nbsp;&nbsp;* allow the garbage collector to remove as many entries from this map as it desires, but there will always be (n)</p><p>&nbsp;&nbsp;&nbsp;* elements retained after a GC due to the strong references.</p><p>&nbsp;&nbsp;&nbsp;* &lt;p/&gt;</p><p>&nbsp;&nbsp;&nbsp;* Note that in a highly concurrent environments the exact total number of strong references may differ slightly</p><p>&nbsp;&nbsp;&nbsp;* than the actual &lt;code&gt;retentionSize&lt;/code&gt; value.&nbsp;This number is intended to be a best-effort retention low</p><p>&nbsp;&nbsp;&nbsp;* water mark.</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param source&nbsp;&nbsp;&nbsp;&nbsp;the backing map to populate this {@code SoftHashMap}</p><p>&nbsp;&nbsp;&nbsp;* @param retentionSize the total number of most recent entries in the map that will be strongly referenced</p><p>&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(retained), preventing them from being eagerly garbage collected by the JVM.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public SoftHashMap(Map&lt;K, V&gt; source, int retentionSize) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;this(retentionSize);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;putAll(source);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public V get(Object key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;V result = null;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SoftValue&lt;V, K&gt; value = map.get(key);</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (value != null) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//unwrap the 'real' value from the SoftReference</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = value.get();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result == null) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The wrapped value was garbage collected, so remove this entry from the backing map:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//noinspection SuspiciousMethodCalls</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.remove(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Add this value to the beginning of the strong reference queue (FIFO).</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addToStrongReferences(result);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return result;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;private void addToStrongReferences(V result) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;strongReferencesLock.lock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strongReferences.add(result);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trimStrongReferencesIfNecessary();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strongReferencesLock.unlock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;//Guarded by the strongReferencesLock in the addToStrongReferences method</p><p><br></p><p>&nbsp;&nbsp;private void trimStrongReferencesIfNecessary() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//trim the strong ref queue if necessary:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;while (strongReferences.size() &gt; RETENTION_SIZE) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strongReferences.poll();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Traverses the ReferenceQueue and removes garbage-collected SoftValue objects from the backing map</p><p>&nbsp;&nbsp;&nbsp;* by looking them up using the SoftValue.key data member.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private void processQueue() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SoftValue sv;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;while ((sv = (SoftValue) queue.poll()) != null) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//noinspection SuspiciousMethodCalls</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.remove(sv.key); // we can access private data!</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public boolean isEmpty() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return map.isEmpty();</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public boolean containsKey(Object key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return map.containsKey(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public boolean containsValue(Object value) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Collection values = values();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return values != null &amp;&amp; values.contains(value);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void putAll(Map&lt;? extends K, ? extends V&gt; m) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (m == null || m.isEmpty()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;for (Map.Entry&lt;? extends K, ? extends V&gt; entry : m.entrySet()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put(entry.getKey(), entry.getValue());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Set&lt;K&gt; keySet() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return map.keySet();</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Collection&lt;V&gt; values() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;K&gt; keys = map.keySet();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (keys.isEmpty()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//noinspection unchecked</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Collections.EMPTY_SET;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;V&gt; values = new ArrayList&lt;V&gt;(keys.size());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;for (K key : keys) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V v = get(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (v != null) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values.add(v);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return values;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Creates a new entry, but wraps the value in a SoftValue instance to enable auto garbage collection.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public V put(K key, V value) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue(); // throw out garbage collected values first</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SoftValue&lt;V, K&gt; sv = new SoftValue&lt;V, K&gt;(value, key, queue);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SoftValue&lt;V, K&gt; previous = map.put(key, sv);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;addToStrongReferences(value);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return previous != null ? previous.get() : null;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public V remove(Object key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue(); // throw out garbage collected values first</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SoftValue&lt;V, K&gt; raw = map.remove(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return raw != null ? raw.get() : null;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void clear() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;strongReferencesLock.lock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strongReferences.clear();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;} finally {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strongReferencesLock.unlock();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue(); // throw out garbage collected values</p><p>&nbsp;&nbsp;&nbsp;&nbsp;map.clear();</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public int size() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue(); // throw out garbage collected values first</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return map.size();</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;processQueue(); // throw out garbage collected values first</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Collection&lt;K&gt; keys = map.keySet();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (keys.isEmpty()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//noinspection unchecked</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Collections.EMPTY_SET;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;K, V&gt; kvPairs = new HashMap&lt;K, V&gt;(keys.size());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;for (K key : keys) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V v = get(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (v != null) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kvPairs.put(key, v);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return kvPairs.entrySet();</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* We define our own subclass of SoftReference which contains</p><p>&nbsp;&nbsp;&nbsp;* not only the value but also the key to make it easier to find</p><p>&nbsp;&nbsp;&nbsp;* the entry in the HashMap after it's been garbage collected.</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private static class SoftValue&lt;V, K&gt; extends SoftReference&lt;V&gt; {</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;private final K key;</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Constructs a new instance, wrapping the value, key, and queue, as</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* required by the superclass.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @param value the map value</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @param key&nbsp;&nbsp;the map key</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @param queue the soft reference queue to poll to determine if the entry had been reaped by the GC.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;&nbsp;&nbsp;private SoftValue(V value, K key, ReferenceQueue&lt;? super V&gt; queue) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(value, queue);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.key = key;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;}</p><p>}</p><p><br></p>