<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-8232f7cc-c07e-4535-b42e-dd076a3afbf5"></attachment><p>package com.lxtx.hello.common.utils;</p><p><br></p><p>import java.io.Serializable;</p><p>import java.util.ArrayList;</p><p>import java.util.HashSet;</p><p>import java.util.Iterator;</p><p>import java.util.List;</p><p>import java.util.Map;</p><p>import java.util.Set;</p><p>import java.util.concurrent.TimeUnit;</p><p><br></p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.dao.DataAccessException;</p><p>import org.springframework.data.redis.connection.RedisConnection;</p><p>import org.springframework.data.redis.connection.StringRedisConnection;</p><p>import org.springframework.data.redis.core.BoundSetOperations;</p><p>import org.springframework.data.redis.core.HashOperations;</p><p>import org.springframework.data.redis.core.ListOperations;</p><p>import org.springframework.data.redis.core.RedisCallback;</p><p>import org.springframework.data.redis.core.RedisTemplate;</p><p>import org.springframework.data.redis.core.ValueOperations;</p><p><br></p><p>import com.alibaba.fastjson.JSON;</p><p>import com.lxtx.hello.common.exception.LxtxException;</p><p><br></p><p>import lombok.extern.slf4j.Slf4j;</p><p>import redis.clients.jedis.Jedis;</p><p>import redis.clients.jedis.JedisCluster;</p><p>import redis.clients.jedis.Tuple;</p><p><br></p><p>/**</p><p>&nbsp;* &lt;p&gt;</p><p>&nbsp;* redis 工具类</p><p>&nbsp;* &lt;/p&gt;</p><p>&nbsp;*</p><p>&nbsp;* @Author LiuLP on 2018/05/15.</p><p>&nbsp;*/</p><p>@SuppressWarnings("Duplicates")</p><p>@Slf4j</p><p>public class RedisCacheUtils&lt;T&gt; {</p><p><br></p><p>&nbsp;&nbsp;@Autowired</p><p>&nbsp;&nbsp;private RedisTemplate redisTemplate;</p><p><br></p><p>&nbsp;&nbsp;private static final String LOCK_SUCCESS = "OK";</p><p>&nbsp;&nbsp;private static final String SET_IF_NOT_EXIST = "NX";</p><p>&nbsp;&nbsp;private static final String SET_WITH_EXPIRE_TIME = "PX";</p><p>&nbsp;&nbsp;private static final Long RELEASE_SUCCESS = 1L;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 两次锁请求之间的间隔时间，100毫秒</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;private static final int DEFAULT_ACQUIRY_RESOLUTION_MILLIS = 100;</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 缓存基本的对象，Integer、String、实体类等</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key&nbsp;&nbsp;缓存的键值</p><p>&nbsp;&nbsp;&nbsp;* @param value 缓存的值</p><p>&nbsp;&nbsp;&nbsp;* @return 缓存的对象</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; ValueOperations&lt;String, T&gt; setCacheObject(String key, T value) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;operation.set(key, value);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return operation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 设置超时的缓存</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param value</p><p>&nbsp;&nbsp;&nbsp;* @param expire</p><p>&nbsp;&nbsp;&nbsp;* @param &lt;T&gt;</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; ValueOperations&lt;String, T&gt; setCacheObject(String key, T value, int expire) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;operation.set(key, value, expire, TimeUnit.SECONDS);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return operation;</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;public &lt;T&gt; ValueOperations&lt;String, T&gt; setCacheObject(String key, T value, long timeout, TimeUnit unit) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;operation.set(key, value, timeout, unit);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return operation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 删除缓存</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public void delete(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.delete(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void expire(String key, Integer time) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;expire(key, time, TimeUnit.SECONDS);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void expire(String key, Integer time, TimeUnit timeUnit) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.expire(key, time, timeUnit);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Long increment(String key, Integer num) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Long increment = redisTemplate.opsForValue().increment(key, num);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return increment;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Double increment(String key, Double num) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Double increment = redisTemplate.opsForValue().increment(key, num);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return increment;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 获得缓存的基本对象。</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key 缓存键值</p><p>&nbsp;&nbsp;&nbsp;* @return 缓存键值对应的数据</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; T getCacheObject(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return operation.get(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 缓存List数据</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key&nbsp;&nbsp;&nbsp;缓存的键值</p><p>&nbsp;&nbsp;&nbsp;* @param dataList 待缓存的List数据</p><p>&nbsp;&nbsp;&nbsp;* @return 缓存的对象</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; ListOperations&lt;String, T&gt; setCacheList(String key, List&lt;T&gt; dataList) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (null != dataList) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size = dataList.size();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; size; i++) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listOperation.leftPush(key, dataList.get(i));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return listOperation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 队列push</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param entity</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public ListOperations&lt;String, T&gt; pushToQueue(String key, T entity) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;listOperation.leftPush(key, entity);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return listOperation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 不阻塞pop</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; T popFromQueue(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return (T) listOperation.rightPop(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 阻塞pop</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; T bRPopFromQueue(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return (T) listOperation.rightPop(key, 0, TimeUnit.SECONDS);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 缓存Set</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key&nbsp;&nbsp;&nbsp;缓存键值</p><p>&nbsp;&nbsp;&nbsp;* @param dataSet 缓存的数据</p><p>&nbsp;&nbsp;&nbsp;* @return 缓存数据的对象</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(String key, Set&lt;T&gt; dataSet) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;T&gt; it = dataSet.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;while (it.hasNext()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setOperation.add(it.next());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return setOperation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 获得缓存的set</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public Set&lt;T&gt; getCacheSet(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;T&gt; dataSet = new HashSet();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;BoundSetOperations&lt;String, T&gt; operation = redisTemplate.boundSetOps(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Long size = operation.size();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; size; i++) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataSet.add(operation.pop());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return dataSet;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 缓存Map</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param dataMap</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; HashOperations&lt;String, String, T&gt; setCacheMap(String key, Map&lt;String, T&gt; dataMap) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HashOperations hashOperations = redisTemplate.opsForHash();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (null != dataMap) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Map.Entry&lt;String, T&gt; entry : dataMap.entrySet()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashOperations.put(key, entry.getKey(), entry.getValue());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return hashOperations;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 获得缓存的Map</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.opsForHash().entries(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 缓存Map</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param dataMap</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; HashOperations&lt;String, Integer, T&gt; setCacheIntegerMap(String key, Map&lt;Integer, T&gt; dataMap) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HashOperations hashOperations = redisTemplate.opsForHash();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (null != dataMap) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (Map.Entry&lt;Integer, T&gt; entry : dataMap.entrySet()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashOperations.put(key, entry.getKey(), entry.getValue());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return hashOperations;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 获得缓存的Maph</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public &lt;T&gt; Map&lt;Integer, T&gt; getCacheIntegerMap(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.opsForHash().entries(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* Redis消息发布</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param channel</p><p>&nbsp;&nbsp;&nbsp;* @param message</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public void publish(String channel, Serializable message) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.convertAndSend(channel, message);</p><p>&nbsp;&nbsp;}</p><p><br></p><p><br></p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 尝试获取分布式锁</p><p>&nbsp;&nbsp;&nbsp;* @param lockKey 锁</p><p>&nbsp;&nbsp;&nbsp;* @param requestId 请求标识</p><p>&nbsp;&nbsp;&nbsp;* @param expireTime 超期时间 ，毫秒单位</p><p>&nbsp;&nbsp;&nbsp;* @return 是否获取成功</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public&nbsp;boolean tryGetDistributedLock(String lockKey, String requestId, int expireTime) {</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;String result = jedisCluster.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;boolean bool = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, expireTime, TimeUnit.MILLISECONDS);</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;if (bool) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return false;</p><p><br></p><p>&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;*&nbsp;获取锁，有重试机制</p><p>&nbsp;&nbsp;&nbsp;* @param lockKey</p><p>&nbsp;&nbsp;&nbsp;* @param requestId&nbsp;解锁人</p><p>&nbsp;&nbsp;&nbsp;* @param expireTime 超时时间，毫秒单位</p><p>&nbsp;&nbsp;&nbsp;* @param retryTime&nbsp;重试时间，毫秒单位</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public&nbsp;boolean tryGetDistributedLock(String lockKey, String requestId, int expireTime,int retryTime) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return tryGetDistributedLock(lockKey, requestId, expireTime, retryTime, DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;*&nbsp;获取锁，有重试机制</p><p>&nbsp;&nbsp;&nbsp;* @param lockKey</p><p>&nbsp;&nbsp;&nbsp;* @param requestId&nbsp;解锁人</p><p>&nbsp;&nbsp;&nbsp;* @param expireTime 超时时间，毫秒单位</p><p>&nbsp;&nbsp;&nbsp;* @param retryTime&nbsp;重试时间，毫秒单位</p><p>&nbsp;&nbsp;&nbsp;* @param interval&nbsp;重试间隔，毫秒单位</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public&nbsp;boolean tryGetDistributedLock(String lockKey, String requestId, int expireTime, int retryTime, int interval) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;//如果重试时间太短，不重试</p><p>&nbsp;&nbsp;&nbsp;&nbsp;int timeout = retryTime - interval;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;if(timeout &lt; 0){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean bool = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, expireTime, TimeUnit.MILLISECONDS);</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = jedisCluster.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bool) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;while (timeout &gt;= 0){</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = jedisCluster.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean bool = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, expireTime, TimeUnit.MILLISECONDS);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bool) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(interval);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error("休眠失败" + e);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw LxtxException.newException("100001","重试失败");</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout -= interval;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;return false;</p><p>&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>&nbsp;&nbsp;private static String unlockRedisScript = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 释放分布式锁</p><p>&nbsp;&nbsp;&nbsp;* @param lockKey 锁</p><p>&nbsp;&nbsp;&nbsp;* @param requestId 请求标识</p><p>&nbsp;&nbsp;&nbsp;* @return 是否释放成功</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public&nbsp;boolean releaseDistributedLock(String lockKey, String requestId) {</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;Object result = jedisCluster.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</p><p>//</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;if (RELEASE_SUCCESS.equals(result)) {</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>//&nbsp;&nbsp;&nbsp;&nbsp;return false;</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;boolean isUnLocked = false;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; keys = new ArrayList&lt;&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; args = new ArrayList&lt;&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys.add(lockKey);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.add(JSON.toJSONString(requestId));</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RedisCallback&lt;Long&gt; callback = (connection) -&gt; {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object nativeConnection = connection.getNativeConnection();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 集群模式和单机模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 集群模式</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nativeConnection instanceof JedisCluster) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (Long) ((JedisCluster) nativeConnection).eval(unlockRedisScript, keys, args);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 单机模式</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (nativeConnection instanceof Jedis) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (Long) ((Jedis) nativeConnection).eval(unlockRedisScript, keys, args);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0L;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Long result = (Long) redisTemplate.execute(callback);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (RELEASE_SUCCESS.equals(result)) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isUnLocked =&nbsp;true;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error("unlock error", e);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;return isUnLocked;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 队列push</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param entity</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public ListOperations&lt;String, T&gt; leftPushAll(String key, List&lt;T&gt; entity) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;listOperation.leftPushAll(key, entity);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return listOperation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 队列push</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param entity</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public ListOperations&lt;String, T&gt; leftPush(String key, T entity) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;listOperation.leftPush(key, entity);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return listOperation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 队列push</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param entity</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public ListOperations&lt;String, T&gt; rightPush(String key, T entity) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;listOperation.rightPush(key, entity);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return listOperation;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 返回list的长度</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public long llen(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations listOperation = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return listOperation.size(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 判断key是否存在</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public boolean exists(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.hasKey(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* zount 统计数量</p><p>&nbsp;&nbsp;&nbsp;* @param redisKey</p><p>&nbsp;&nbsp;&nbsp;* @param startTime</p><p>&nbsp;&nbsp;&nbsp;* @param endTime</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public Long zcount(String redisKey, double startTime, double endTime) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.opsForZSet().count(redisKey, startTime, endTime);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Long zcount(String redisKey) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.opsForZSet().size(redisKey);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Set&lt;?&gt; zrange(String redisKey, long start, long end) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.opsForZSet().range(redisKey, start, end);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Set&lt;Tuple&gt; zrangeByScoreWithScores(String redisKey, double startTime, double endTime) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return redisTemplate.opsForZSet().rangeByScoreWithScores(redisKey, startTime, endTime);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void zadd(String redisKey, double timeStamp, Object s) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.opsForZSet().add(redisKey, s, timeStamp);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void zremrangeByScore(String redisKey, double startTime, double endTime) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;redisTemplate.opsForZSet().removeRangeByScore(redisKey, startTime, endTime);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void setString(String key, String value, Long time, TimeUnit timeUnit) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, String&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;operation.set(key, value, time, timeUnit);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public void setInteger(String key, Integer value, Long time, TimeUnit timeUnit) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, String&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;operation.set(key, String.valueOf(value), time, timeUnit);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public String getString(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, String&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return operation.get(key);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;public Integer getInteger(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ValueOperations&lt;String, String&gt; operation = redisTemplate.opsForValue();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;String value = operation.get(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return value == null ? 0 : Integer.parseInt(value);</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 返回list区间数据</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key</p><p>&nbsp;&nbsp;&nbsp;* @param start</p><p>&nbsp;&nbsp;&nbsp;* @param end</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public List&lt;T&gt; lrange(String key, long start, long end) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;ListOperations&lt;String, T&gt; listOperations = redisTemplate.opsForList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt; list = listOperations.range(key, start, end);</p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;return list;</p><p>&nbsp;&nbsp;}</p><p><br></p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 获取全部list缓存</p><p>&nbsp;&nbsp;&nbsp;*</p><p>&nbsp;&nbsp;&nbsp;* @param key 键</p><p>&nbsp;&nbsp;&nbsp;* @return 列表</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public List&lt;T&gt; lrange(String key) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;return lrange(key, 0, -1);</p><p>&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;/**</p><p>&nbsp;&nbsp;&nbsp;* 批量更新 cache 注:待验证</p><p>&nbsp;&nbsp;&nbsp;* @param keyValueMap</p><p>&nbsp;&nbsp;&nbsp;* @param expire</p><p>&nbsp;&nbsp;&nbsp;* @return</p><p>&nbsp;&nbsp;&nbsp;*/</p><p>&nbsp;&nbsp;public List&lt;T&gt; updateBatch(Map&lt;String,Object&gt; keyValueMap,long expire){</p><p>&nbsp;&nbsp;	List&lt;T&gt; result = redisTemplate.executePipelined(</p><p>&nbsp;&nbsp;			new RedisCallback&lt;T&gt;(){</p><p>					@Override</p><p>					public T doInRedis(RedisConnection connection) throws DataAccessException {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringRedisConnection stringRedisConn = (StringRedisConnection)connection;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(String key:keyValueMap.keySet()) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(null != keyValueMap.get(key)){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringRedisConn.set(key, keyValueMap.get(key).toString());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringRedisConn.expire(key,expire);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</p><p>					}</p><p>&nbsp;&nbsp;			}) ;</p><p>&nbsp;&nbsp;	return result ;</p><p>&nbsp;&nbsp;}</p><p><br></p><p><br></p><p>}</p><p><br></p>