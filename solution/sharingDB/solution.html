<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-7bbe802e-cd70-493a-a651-1e20f99cc175"></attachment><p class="ql-align-justify">本文将以“用户中心”为例，介绍“单KEY”类业务，随着数据量的逐步增大，数据库性能显著降低，数据库水平切分相关的架构实践：</p><ul><li class="ql-align-justify">如何来实施水平切分</li><li class="ql-align-justify">水平切分后常见的问题</li><li class="ql-align-justify">典型问题的优化思路及实践</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>一、用户中心</strong></p><p class="ql-align-justify">用户中心是一个非常常见的业务，主要提供<span style="color: rgb(255, 76, 0);">用户注册、登录、信息查询与修改</span>的服务，其核心元数据为：</p><p class="ql-align-justify">User(uid, login_name, passwd, sex, age, nickname, …)</p><p class="ql-align-justify">其中：</p><ul><li class="ql-align-justify">uid为用户ID，主键</li><li class="ql-align-justify">login_name, passwd, sex, age, nickname, …等用户属性</li></ul><p class="ql-align-justify">数据库设计上，一般来说在业务<strong>初期</strong>，<span style="color: rgb(255, 76, 0);">单库单表</span>就能够搞定这个需求，典型的架构设计为：</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUamdriaAWKQibIiafx1ud6DWiaApc0fFRzC6X2vgb9Vp29xoFEpFjFUw7Hg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><ul><li class="ql-align-justify">user-center：用户中心服务，对调用者提供友好的RPC接口</li><li class="ql-align-justify">user-db：对用户进行数据存储</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>二、用户中心水平切分方法</strong></p><p class="ql-align-justify">当<strong>数据量越来越大时</strong>，需要对数据库进行<span style="color: rgb(255, 76, 0);">水平切分</span>，常见的水平切分算法有<strong>“范围法”和“哈希法”</strong>。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>范围法</strong>，以用户中心的业务主键uid为划分依据，将数据水平切分到两个数据库实例上去：</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrU03JIxwdPWIQbcV948AJdUxg3uNDbIp4ibzOaibTuv8YYGXYYazmzZ2Fg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><ul><li class="ql-align-justify">user-db1：存储0到1千万的uid数据</li><li class="ql-align-justify">user-db2：存储1到2千万的uid数据</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">范围法的<strong>优点</strong>是：</p><ul><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">切分策略简单</span>，根据uid，按照范围，user- center很快能够定位到数据在哪个库上</li><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">扩容简单</span>，如果容量不够，只要增加user-db3即可</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify">范围法的<strong>不足</strong>是：</p><ul><li class="ql-align-justify">uid必须要满足<span style="color: rgb(255, 76, 0);">递增的特性</span></li><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">数据量不均</span>，新增的user-db3，在初期的数据会比较少</li><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">请求量不均</span>，一般来说，新注册的用户活跃度会比较高，故user-db2往往会比user-db1负载要高，导致服务器利用率不平衡</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>哈希法</strong>，也是以用户中心的业务主键uid为划分依据，将数据水平切分到两个数据库实例上去：</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUJCkytKRyvvmNyOkKRUoYATZWQnUnvZX7KLRjCS9T5f4vPJmaZvwaew/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><ul><li class="ql-align-justify">user-db1：存储uid取模得1的uid数据</li><li class="ql-align-justify">user-db2：存储uid取模得0的uid数据</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">哈希法的<strong>优点</strong>是：</p><ul><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">切分策略简单</span>，根据uid，按照hash，user-center很快能够定位到数据在哪个库上</li><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">数据量均衡</span>，只要uid是均匀的，数据在各个库上的分布一定是均衡的</li><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">请求量均衡</span>，只要uid是均匀的，负载在各个库上的分布一定是均衡的</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify">哈希法的<strong>不足</strong>是：</p><ul><li class="ql-align-justify"><span style="color: rgb(255, 76, 0);">扩容麻烦</span>，如果容量不够，要增加一个库，重新hash可能会导致数据迁移，如何平滑的进行数据迁移，是一个需要解决的问题</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>三、用户中心水平切分后带来的问题</strong></p><p class="ql-align-justify">使用uid来进行水平切分之后，整个用户中心的业务访问会遇到什么问题呢？</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><span style="color: rgb(255, 76, 0);">对于uid属性上的查询可以直接路由到库</span>，假设访问uid=124的数据，取模后能够直接定位db-user1：</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUI3nHV2L7XibF1LQ7cbZPVYG99FdRCWmJibriaH5RPqxChA2AG75s3RV6w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><span style="color: rgb(255, 76, 0);">对于非uid属性上的查询，例如login_name属性上的查询，就悲剧了</span>：</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrU2B5icaoyyxCPnEUsS06rHhLRHBw6avcW5Wl0JGtV2cmNUF1T1urdoKQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">假设访问login_name=shenjian的数据，由于不知道数据落在哪个库上，往往需要遍历所有库，当分库数量多起来，性能会显著降低。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">如何解决分库后，非uid属性上的查询问题，是后文要重点讨论的内容。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>四、用户中心非uid属性查询需求分析</strong></p><p class="ql-align-justify"><span style="color: rgb(255, 76, 0);">任何脱离业务的架构设计都是耍流氓</span>，在进行架构讨论之前，先来对业务进行简要分析，看非uid属性上有哪些查询需求。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">根据楼主这些年的架构经验，用户中心非uid属性上经常有两类业务需求：</p><p class="ql-align-justify">（1）<strong>用户侧，前台访问</strong>，最典型的有两类需求</p><p class="ql-align-justify"><span style="color: rgb(255, 76, 0);">用户登录</span>：通过login_name/phone/email查询用户的实体，1%请求属于这种类型</p><p class="ql-align-justify"><span style="color: rgb(255, 76, 0);">用户信息查询</span>：登录之后，通过uid来查询用户的实例，99%请求属这种类型</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">用户侧的查询基本上是单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">（2）<strong>运营侧，后台访问</strong>，根据产品、运营需求，访问模式各异，按照<span style="color: rgb(255, 76, 0);">年龄、性别、头像、登陆时间、注册时间来进行查询</span>。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">运营侧的查询基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">这两类不同的业务需求，应该使用什么样的架构方案来解决呢？</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>五、用户中心水平切分架构思路</strong></p><p class="ql-align-justify">用户中心在数据量较大的情况下，使用uid进行水平切分，对于非uid属性上的查询需求，架构设计的核心思路为：</p><ul><li class="ql-align-justify">针对<strong>用户侧</strong>，应该采用“<span style="color: rgb(255, 76, 0);">建立非uid属性到uid的映射关系</span>”的架构方案</li><li class="ql-align-justify">针对<strong>运营侧</strong>，应该采用“<span style="color: rgb(255, 76, 0);">前台与后台分离</span>”的架构方案</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>六、用户中心-用户侧最佳实践</strong></p><p class="ql-align-justify"><strong>【索引表法】</strong></p><p class="ql-align-justify"><strong>思路</strong>：uid能直接定位到库，login_name不能直接定位到库，如果通过login_name能查询到uid，问题解决</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>解决方案</strong>：</p><ul><li class="ql-align-justify">建立一个索引表记录login_name-&gt;uid的映射关系</li><li class="ql-align-justify">用login_name来访问时，先通过索引表查询到uid，再定位相应的库</li><li class="ql-align-justify">索引表属性较少，可以容纳非常多数据，一般不需要分库</li><li class="ql-align-justify">如果数据量过大，可以通过login_name来分库</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify">潜在<strong>不足</strong>：多一次数据库查询，性能下降一倍</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>【缓存映射法】</strong></p><p class="ql-align-justify"><strong>思路</strong>：访问索引表性能较低，把映射关系放在缓存里性能更佳</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>解决方案</strong>：</p><ul><li class="ql-align-justify">login_name查询先到cache中查询uid，再根据uid定位数据库</li><li class="ql-align-justify">假设cache miss，采用扫全库法获取login_name对应的uid，放入cache</li><li class="ql-align-justify">login_name到uid的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高</li><li class="ql-align-justify">如果数据量过大，可以通过login_name进行cache水平切分</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify">潜在<strong>不足</strong>：多一次cache查询</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>【login_name生成uid】</strong></p><p class="ql-align-justify"><strong>思路</strong>：不进行远程查询，由login_name直接得到uid</p><p class="ql-align-justify"><br></p><p class="ql-align-justify"><strong>解决方案</strong>：</p><ul><li class="ql-align-justify">在用户注册时，设计函数login_name生成uid，uid=f(login_name)，按uid分库插入数据</li><li class="ql-align-justify">用login_name来访问时，先通过函数计算出uid，即uid=f(login_name)再来一遍，由uid路由到对应库</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify">潜在<strong>不足</strong>：该函数设计需要非常讲究技巧，有uid生成冲突风险</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>【login_name基因融入uid】</strong></p><p class="ql-align-justify"><strong>思路</strong>：不能用login_name生成uid，可以从login_name抽取“基因”，融入uid中</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUiaibCbjwaqEl9MOaIclIbqfrAMiaRRZSNeaQchyxuiaxlvd0fkerI04aFA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">假设分8库，采用uid%8路由，潜台词是，uid的最后3个bit决定这条数据落在哪个库上，这3个bit就是所谓的“基因”。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>解决方案</strong>：</p><ul><li class="ql-align-justify">在用户注册时，设计函数login_name生成3bit基因，login_name_gene=f(login_name)，如上图粉色部分</li><li class="ql-align-justify">同时，生成61bit的全局唯一id，作为用户的标识，如上图绿色部分</li><li class="ql-align-justify">接着把3bit的login_name_gene也作为uid的一部分，如上图屎黄色部分</li><li class="ql-align-justify">生成64bit的uid，由id和login_name_gene拼装而成，并按照uid分库插入数据</li><li class="ql-align-justify">用login_name来访问时，先通过函数由login_name再次复原3bit基因，login_name_gene=f(login_name)，通过login_name_gene%8直接定位到库</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>七、用户中心-运营侧最佳实践</strong></p><p class="ql-align-justify">前台<strong>用户侧</strong>，业务需求基本都是<span style="color: rgb(255, 76, 0);">单行记录的访问</span>，只要建立非uid属性&nbsp;login_name / phone / email&nbsp;到uid的映射关系，就能解决问题。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">后台<strong>运营侧</strong>，业务需求各异，基本是<span style="color: rgb(255, 76, 0);">批量分页</span>的访问，这类访问计算量较大，返回数据量较大，比较消耗数据库性能。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">如果此时前台业务和后台业务公用一批服务和一个数据库，有可能导致，由于后台的“少数几个请求”的“批量查询”的“低效”访问，导致数据库的cpu偶尔瞬时100%，影响前台正常用户的访问（例如，登录超时）。</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrU28Rr6w5cVaicnRrgNibpibKmbUKM2ePWueMT44rsZDKuOqlNOTtR5icVpg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">而且，为了满足后台业务各类“奇形怪状”的需求，往往会在数据库上建立各种索引，这些索引占用大量内存，会使得用户侧前台业务uid/login_name上的查询性能与写入性能大幅度降低，处理时间增长。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify">对于这一类业务，应该采用<span style="color: rgb(255, 76, 0);">“前台与后台分离”的架构方案</span>：</p><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUWp4R0xh5GUiaI9FzvcXdrPGEMY1l3vnDr9KjTKxagGqayN4NdJvtZxQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">用户侧前台业务需求架构依然不变，产品运营侧后台业务需求则<strong>抽取独立的web / service / db&nbsp;来支持</strong>，<span style="color: rgb(255, 76, 0);">解除系统之间的耦合</span>，对于“业务复杂”“并发量低”“无需高可用”“能接受一定延时”的后台业务：</p><ul><li class="ql-align-justify">可以去掉service层，在运营后台web层通过dao直接访问db</li><li class="ql-align-justify">不需要反向代理，不需要集群冗余</li><li class="ql-align-justify">不需要访问实时库，可以通过MQ或者线下异步同步数据</li><li class="ql-align-justify">在数据库非常大的情况下，可以使用更契合大量数据允许接受更高延时的“索引外置”或者“HIVE”的设计方案</li></ul><p class="ql-align-justify"><img src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOyykHzqPok3phVUTtOoMnrUGvNtllkhu7qosvWPhj5BaQAacK6xrnvPSg5yO4toiaKJF9qjYvdkdtw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>八、总结</strong></p><p class="ql-align-justify">将以“用户中心”为典型的“单KEY”类业务，水平切分的架构点，本文做了这样一些介绍。</p><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>水平切分方式</strong>：</p><ul><li class="ql-align-justify">范围法</li><li class="ql-align-justify">哈希法</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>水平切分后碰到的问题</strong>：</p><ul><li class="ql-align-justify">通过uid属性查询能直接定位到库，通过非uid属性查询不能定位到库</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>非uid属性查询的典型业务</strong>：</p><ul><li class="ql-align-justify">用户侧，前台访问，单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高</li><li class="ql-align-justify">运营侧，后台访问，根据产品、运营需求，访问模式各异，基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>这两类业务的架构设计思路</strong>：</p><ul><li class="ql-align-justify">针对用户侧，应该采用“建立非uid属性到uid的映射关系”的架构方案</li><li class="ql-align-justify">针对运营侧，应该采用“前台与后台分离”的架构方案</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>用户前台侧，“建立非uid属性到uid的映射关系”最佳实践</strong>：</p><ul><li class="ql-align-justify">索引表法：数据库中记录login_name-&gt;uid的映射关系</li><li class="ql-align-justify">缓存映射法：缓存中记录login_name-&gt;uid的映射关系</li><li class="ql-align-justify">login_name生成uid</li><li class="ql-align-justify">login_name基因融入uid</li></ul><p class="ql-align-justify">&nbsp;</p><p class="ql-align-justify"><strong>运营后台侧，“前台与后台分离”最佳实践</strong>：</p><ul><li class="ql-align-justify">前台、后台系统web/service/db分离解耦，避免后台低效查询引发前台查询抖动</li><li class="ql-align-justify">可以采用数据冗余的设计方式</li><li class="ql-align-justify">可以采用“外置索引”（例如ES搜索系统）或者“大数据处理”（例如HIVE）来满足后台变态的查询需求</li></ul><p class="ql-align-justify"><br></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">其他类型业务的水平切分架构方案，未来和大家聊。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">希望大伙有收获。</p><p><br></p>